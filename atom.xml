<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>许三金的博客</title>
  
  <subtitle>言念君子，溫其如玉</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://xusanjin.com/"/>
  <updated>2021-08-18T12:53:39.005Z</updated>
  <id>http://xusanjin.com/</id>
  
  <author>
    <name>许三金</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>括号生成</title>
    <link href="http://xusanjin.com/2021/08/18/arithmetic101/"/>
    <id>http://xusanjin.com/2021/08/18/arithmetic101/</id>
    <published>2021-08-18T12:34:00.000Z</published>
    <updated>2021-08-18T12:53:39.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>数字 <code>n</code> 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 <strong>有效的</strong> 括号组合。</p><p>有效括号组合需满足：左括号必须以正确的顺序闭合。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：n = 3</p><p>输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]</p></blockquote><a id="more"></a><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li><code>1 &lt;= n &lt;= 8</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">public</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">generateParenthesis</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">return</span> res<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token function">getParenthesis</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span>n<span class="token punctuation">,</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">getParenthesis</span><span class="token punctuation">(</span>String str<span class="token punctuation">,</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">)</span><span class="token punctuation">{</span>                res<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">==</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//剩余左右括号数相等，下一个只能用左括号</span>                <span class="token function">getParenthesis</span><span class="token punctuation">(</span>str<span class="token operator">+</span><span class="token string">"("</span><span class="token punctuation">,</span>left<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">//剩余左括号小于右括号，下一个可以用左括号也可以用右括号</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>left <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token function">getParenthesis</span><span class="token punctuation">(</span>str<span class="token operator">+</span><span class="token string">"("</span><span class="token punctuation">,</span>left<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token function">getParenthesis</span><span class="token punctuation">(</span>str<span class="token operator">+</span><span class="token string">")"</span><span class="token punctuation">,</span>left<span class="token punctuation">,</span>right<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;数字 &lt;code&gt;n&lt;/code&gt; 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且 &lt;strong&gt;有效的&lt;/strong&gt; 括号组合。&lt;/p&gt;
&lt;p&gt;有效括号组合需满足：左括号必须以正确的顺序闭合。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入：n = 3&lt;/p&gt;
&lt;p&gt;输出：[“((()))”,”(()())”,”(())()”,”()(())”,”()()()”]&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>整数反转</title>
    <link href="http://xusanjin.com/2021/08/18/arithmetic100/"/>
    <id>http://xusanjin.com/2021/08/18/arithmetic100/</id>
    <published>2021-08-18T11:54:00.000Z</published>
    <updated>2021-08-18T12:34:05.740Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。</p><p>如果反转后整数超过 32 位的有符号整数的范围 [−2<sup>31</sup>,  2<sup>31</sup> − 1] ，就返回 0。</p><p><strong>假设环境不允许存储 64 位整数（有符号或无符号）。</strong></p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：x = 123</p><p>输出：321</p></blockquote><a id="more"></a><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li>-2<sup>31</sup> &lt;= x &lt;= 2<sup>31</sup> - 1</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>越界前提前判断</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> rev <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rev <span class="token operator">&lt;</span> Integer<span class="token punctuation">.</span>MIN_VALUE <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">||</span> rev <span class="token operator">></span> Integer<span class="token punctuation">.</span>MAX_VALUE <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> digit <span class="token operator">=</span> x <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            x <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">;</span>            rev <span class="token operator">=</span> rev <span class="token operator">*</span> <span class="token number">10</span> <span class="token operator">+</span> digit<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> rev<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个 32 位的有符号整数 x ，返回将 x 中的数字部分反转后的结果。&lt;/p&gt;
&lt;p&gt;如果反转后整数超过 32 位的有符号整数的范围 [−2&lt;sup&gt;31&lt;/sup&gt;,  2&lt;sup&gt;31&lt;/sup&gt; − 1] ，就返回 0。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;假设环境不允许存储 64 位整数（有符号或无符号）。&lt;/strong&gt;&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入：x = 123&lt;/p&gt;
&lt;p&gt;输出：321&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>无重复字符的最长子串</title>
    <link href="http://xusanjin.com/2021/08/18/arithmetic99/"/>
    <id>http://xusanjin.com/2021/08/18/arithmetic99/</id>
    <published>2021-08-18T09:20:00.000Z</published>
    <updated>2021-08-18T11:40:25.513Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串 <code>s</code> ，请你找出其中不含有重复字符的 <strong>最长子串</strong> 的长度。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：s = “abcabcbb”</p><p>输出：3</p><p>解释：因为无重复字符的最长子串是 “abc”，所以其长度为 3。</p></blockquote><a id="more"></a><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li><code>0 &lt;= s.length &lt;= 5 * 104</code></li><li><code>s</code> 由英文字母、数字、符号和空格组成</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>暴力解法时间复杂度较高，会达到 O(n<sup>2</sup>)，故而采取滑动窗口的方法降低时间复杂度<br>定义一个 map 数据结构存储 (k, v)，其中 key 值为字符，value 值为字符位置 +1，加 1 表示从字符位置后一个才开始不重复<br>我们定义不重复子串的开始位置为 start，结束位置为 end<br>随着 end 不断遍历向后，会遇到与 [start, end] 区间内字符相同的情况，此时将字符作为 key 值，获取其 value 值，并更新 start，此时 [start, end] 区间内不存在重复字符<br>无论是否更新 start，都会更新其 map 数据结构和结果 ans。<br>时间复杂度：O(n)</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lengthOfLongestSubstring</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        Map<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> end <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> end<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> alpha <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>alpha<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                start <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>alpha<span class="token punctuation">)</span><span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            ans <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>ans<span class="token punctuation">,</span> end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">,</span> end <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 如果要输出最长子串时</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * 无重复字符的最长子串         */</span>        Scanner scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        String s <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> t <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> v <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        HashMap<span class="token operator">&lt;</span>Character<span class="token punctuation">,</span> Integer<span class="token operator">></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> end <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> end <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> end<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">char</span> alpha <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>alpha<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                start <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>alpha<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> start<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>ans <span class="token operator">&lt;</span> end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                t <span class="token operator">=</span> start<span class="token punctuation">;</span>                v <span class="token operator">=</span> end<span class="token punctuation">;</span>                ans <span class="token operator">=</span> end <span class="token operator">-</span> start <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">,</span> end<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span>v<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个字符串 &lt;code&gt;s&lt;/code&gt; ，请你找出其中不含有重复字符的 &lt;strong&gt;最长子串&lt;/strong&gt; 的长度。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入：s = “abcabcbb”&lt;/p&gt;
&lt;p&gt;输出：3&lt;/p&gt;
&lt;p&gt;解释：因为无重复字符的最长子串是 “abc”，所以其长度为 3。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>最长公共子序列</title>
    <link href="http://xusanjin.com/2021/08/17/arithmetic98/"/>
    <id>http://xusanjin.com/2021/08/17/arithmetic98/</id>
    <published>2021-08-17T09:04:00.000Z</published>
    <updated>2021-08-18T09:21:10.216Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定两个字符串 text1 和 text2，返回这两个字符串的最长 <strong>公共子序列</strong> 的长度。如果不存在 <strong>公共子序列</strong> ，返回 0 。</p><p>一个字符串的 <strong>子序列</strong> 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。</p><ul><li>例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。</li></ul><p>两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：text1 = “abcde”, text2 = “ace” </p><p>输出：3</p><p>解释：最长公共子序列是 “ace” ，它的长度为 3 。</p></blockquote><a id="more"></a><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li><code>1 &lt;= text1.length, text2.length &lt;= 1000</code></li><li><code>text1</code> 和 <code>text2</code> 仅由小写英文字符组成。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p><p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p><p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p><p><img src="/2021/08/17/arithmetic98/1.jpg" alt loading="lazy"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">longestCommonSubsequence</span><span class="token punctuation">(</span>String text1<span class="token punctuation">,</span> String text2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> n <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>m <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> m<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> c1 <span class="token operator">=</span> text1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> n<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">char</span> c2 <span class="token operator">=</span> text2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>c1 <span class="token operator">==</span> c2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> dp<span class="token punctuation">[</span>m<span class="token punctuation">]</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定两个字符串 text1 和 text2，返回这两个字符串的最长 &lt;strong&gt;公共子序列&lt;/strong&gt; 的长度。如果不存在 &lt;strong&gt;公共子序列&lt;/strong&gt; ，返回 0 。&lt;/p&gt;
&lt;p&gt;一个字符串的 &lt;strong&gt;子序列&lt;/strong&gt; 是指这样一个新的字符串：它是由原字符串在不改变字符的相对顺序的情况下删除某些字符（也可以不删除任何字符）后组成的新字符串。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，”ace” 是 “abcde” 的子序列，但 “aec” 不是 “abcde” 的子序列。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;两个字符串的 公共子序列 是这两个字符串所共同拥有的子序列。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入：text1 = “abcde”, text2 = “ace” &lt;/p&gt;
&lt;p&gt;输出：3&lt;/p&gt;
&lt;p&gt;解释：最长公共子序列是 “ace” ，它的长度为 3 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LRU 缓存机制</title>
    <link href="http://xusanjin.com/2021/08/17/arithmetic97/"/>
    <id>http://xusanjin.com/2021/08/17/arithmetic97/</id>
    <published>2021-08-17T09:03:00.000Z</published>
    <updated>2021-08-18T03:51:47.758Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。<br>实现 LRUCache 类：</p><ul><li><code>LRUCache(int capacity)</code> 以正整数作为容量 <code>capacity</code> 初始化 LRU 缓存</li><li><code>int get(int key)</code> 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。</li><li><code>void put(int key, int value)</code> 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。</li></ul><p><strong>进阶：</strong>你是否可以在 O(1) 时间复杂度内完成这两种操作？</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]<br>          [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]</p><p>输出：[null, null, null, 1, null, -1, null, -1, 3, 4]</p><p>解释：</p><p>LRUCache lRUCache = new LRUCache(2);<br>lRUCache.put(1, 1); // 缓存是 {1=1}<br>lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}<br>lRUCache.get(1);    // 返回 1<br>lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}<br>lRUCache.get(2);    // 返回 -1 (未找到)<br>lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}<br>lRUCache.get(1);    // 返回 -1 (未找到)<br>lRUCache.get(3);    // 返回 3<br>lRUCache.get(4);    // 返回 4</p></blockquote><a id="more"></a><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li>1 &lt;= capacity &lt;= 3000</li><li>0 &lt;= key &lt;= 10000</li><li>0 &lt;= value &lt;= 105</li><li>最多调用 2 * 105 次 get 和 put</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>LRU 缓存机制可以通过哈希表辅以双向链表实现，我们用一个哈希表和一个双向链表维护所有在缓存中的键值对。</p><p>双向链表按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。</p><p>哈希表即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。</p><p><img src="/2021/08/17/arithmetic97/1.png" alt loading="lazy"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>    <span class="token keyword">class</span> <span class="token class-name">DLinkedNode</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> key<span class="token punctuation">;</span>        <span class="token keyword">int</span> value<span class="token punctuation">;</span>        DLinkedNode prev<span class="token punctuation">;</span>        DLinkedNode next<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">DLinkedNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token function">DLinkedNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> _key<span class="token punctuation">,</span> <span class="token keyword">int</span> _value<span class="token punctuation">)</span> <span class="token punctuation">{</span>key <span class="token operator">=</span> _key<span class="token punctuation">;</span> value <span class="token operator">=</span> _value<span class="token punctuation">;</span><span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> DLinkedNode<span class="token operator">></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> DLinkedNode<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>    <span class="token keyword">private</span> DLinkedNode head<span class="token punctuation">,</span> tail<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用伪头部和伪尾部节点</span>        head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>        tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        DLinkedNode node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果 key 存在，先通过哈希表定位，再移到头部</span>        <span class="token function">moveToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        DLinkedNode node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>node <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果 key 不存在，创建一个新的节点</span>            DLinkedNode newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 添加进哈希表</span>            cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 添加至双向链表的头部</span>            <span class="token function">addToHead</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token operator">++</span>size<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">></span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 如果超出容量，删除双向链表的尾部节点</span>                DLinkedNode tail <span class="token operator">=</span> <span class="token function">removeTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 删除哈希表中对应的项</span>                cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tail<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token operator">--</span>size<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部</span>            node<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token function">moveToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addToHead</span><span class="token punctuation">(</span>DLinkedNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>        head<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeNode</span><span class="token punctuation">(</span>DLinkedNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">moveToHead</span><span class="token punctuation">(</span>DLinkedNode node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">addToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> DLinkedNode <span class="token function">removeTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        DLinkedNode res <span class="token operator">=</span> tail<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>        <span class="token function">removeNode</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;运用你所掌握的数据结构，设计和实现一个  LRU (最近最少使用) 缓存机制 。&lt;br&gt;实现 LRUCache 类：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;LRUCache(int capacity)&lt;/code&gt; 以正整数作为容量 &lt;code&gt;capacity&lt;/code&gt; 初始化 LRU 缓存&lt;/li&gt;
&lt;li&gt;&lt;code&gt;int get(int key)&lt;/code&gt; 如果关键字 key 存在于缓存中，则返回关键字的值，否则返回 -1 。&lt;/li&gt;
&lt;li&gt;&lt;code&gt;void put(int key, int value)&lt;/code&gt; 如果关键字已经存在，则变更其数据值；如果关键字不存在，则插入该组「关键字-值」。当缓存容量达到上限时，它应该在写入新数据之前删除最久未使用的数据值，从而为新的数据值留出空间。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;进阶：&lt;/strong&gt;你是否可以在 O(1) 时间复杂度内完成这两种操作？&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入：[“LRUCache”, “put”, “put”, “get”, “put”, “get”, “put”, “get”, “get”, “get”]&lt;br&gt;          [[2], [1, 1], [2, 2], [1], [3, 3], [2], [4, 4], [1], [3], [4]]&lt;/p&gt;
&lt;p&gt;输出：[null, null, null, 1, null, -1, null, -1, 3, 4]&lt;/p&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;p&gt;LRUCache lRUCache = new LRUCache(2);&lt;br&gt;lRUCache.put(1, 1); // 缓存是 {1=1}&lt;br&gt;lRUCache.put(2, 2); // 缓存是 {1=1, 2=2}&lt;br&gt;lRUCache.get(1);    // 返回 1&lt;br&gt;lRUCache.put(3, 3); // 该操作会使得关键字 2 作废，缓存是 {1=1, 3=3}&lt;br&gt;lRUCache.get(2);    // 返回 -1 (未找到)&lt;br&gt;lRUCache.put(4, 4); // 该操作会使得关键字 1 作废，缓存是 {4=4, 3=3}&lt;br&gt;lRUCache.get(1);    // 返回 -1 (未找到)&lt;br&gt;lRUCache.get(3);    // 返回 3&lt;br&gt;lRUCache.get(4);    // 返回 4&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>两数之和</title>
    <link href="http://xusanjin.com/2021/08/16/arithmetic96/"/>
    <id>http://xusanjin.com/2021/08/16/arithmetic96/</id>
    <published>2021-08-16T09:03:00.000Z</published>
    <updated>2021-08-18T03:51:47.754Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 <strong>和为目标值</strong> target  的那 <strong>两个</strong> 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：nums = [2,7,11,15], target = 9</p><p>输出：[0,1]</p><p>解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</p></blockquote><a id="more"></a><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li><code>2 &lt;= nums.length &lt;= 104</code></li><li><code>-109 &lt;= nums[i] &lt;= 109</code></li><li><code>-109 &lt;= target &lt;= 109</code></li><li><strong>只会存在一个有效答案</strong></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>使用哈希表，可以将寻找 <code>target - x</code> 的时间复杂度降低到从 O<em>(</em>N<em>) 降低到  O</em>(1)。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">twoSum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> hashtable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>hashtable<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span>hashtable<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target <span class="token operator">-</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token punctuation">}</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            hashtable<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 &lt;strong&gt;和为目标值&lt;/strong&gt; target  的那 &lt;strong&gt;两个&lt;/strong&gt; 整数，并返回它们的数组下标。&lt;/p&gt;
&lt;p&gt;你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。&lt;/p&gt;
&lt;p&gt;你可以按任意顺序返回答案。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入：nums = [2,7,11,15], target = 9&lt;/p&gt;
&lt;p&gt;输出：[0,1]&lt;/p&gt;
&lt;p&gt;解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>第 N 位数字</title>
    <link href="http://xusanjin.com/2021/08/16/arithmetic95/"/>
    <id>http://xusanjin.com/2021/08/16/arithmetic95/</id>
    <published>2021-08-16T08:25:00.000Z</published>
    <updated>2021-08-18T03:51:47.746Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n 位数字。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：11</p><p>输出：0</p><p>解释：第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … 里是 0 ，它是 10 的一部分。</p></blockquote><a id="more"></a><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li>n 是正数且在 32 位整数范围内（n &lt; 2<sup>31</sup>）。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>对于第 n 位对应的数字，我们令这个数字对应的数为 target，然后分三步进行。</p><ul><li>首先找到这个数字对应的数是几位数，用 digits 表示；</li><li>然后确定这个对应的数的数值 target；</li><li>最后确定返回值是 target 中的哪个数字。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">findNthDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span> num<span class="token operator">=</span>n<span class="token punctuation">;</span>        <span class="token keyword">long</span> size<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">long</span> max<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>n<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">//判断不在当前位数内</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>num<span class="token operator">-</span>max<span class="token operator">*</span>size<span class="token operator">></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                num<span class="token operator">=</span>num<span class="token operator">-</span>max<span class="token operator">*</span>size<span class="token punctuation">;</span>                size<span class="token operator">++</span><span class="token punctuation">;</span>                max<span class="token operator">=</span>max<span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                <span class="token keyword">long</span> count<span class="token operator">=</span>num<span class="token operator">/</span>size<span class="token punctuation">;</span>                <span class="token keyword">long</span> left<span class="token operator">=</span>num<span class="token operator">%</span>size<span class="token punctuation">;</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>left<span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>                    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token operator">+</span>count<span class="token punctuation">)</span><span class="token operator">/</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span>Math<span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>size<span class="token operator">-</span>left<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;在无限的整数序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, …中找到第 n 位数字。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入：11&lt;/p&gt;
&lt;p&gt;输出：0&lt;/p&gt;
&lt;p&gt;解释：第 11 位数字在序列 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, … 里是 0 ，它是 10 的一部分。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Java面试知识汇总</title>
    <link href="http://xusanjin.com/2021/08/16/java/"/>
    <id>http://xusanjin.com/2021/08/16/java/</id>
    <published>2021-08-16T03:25:06.000Z</published>
    <updated>2021-08-18T03:51:47.880Z</updated>
    
    <content type="html"><![CDATA[<h2 id="面向过程和面向对象的区别"><a href="#面向过程和面向对象的区别" class="headerlink" title="面向过程和面向对象的区别"></a><strong>面向过程和面向对象的区别</strong></h2><ul><li><strong>面向过程：面向过程性能比面向对象高</strong>。因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，<strong>面向过程没有面向对象易维护、易复用、易扩展</strong>。</li><li><strong>面向对象：面向对象易维护、易复用、易扩展</strong>。因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易维护。但是，<strong>面向对象性能比面向过程低</strong>。<a id="more"></a></li></ul><hr><h2 id="Java语言有哪些特点"><a href="#Java语言有哪些特点" class="headerlink" title="Java语言有哪些特点?"></a><strong>Java语言有哪些特点?</strong></h2><ul><li>简单易学；</li><li>面向对象（<font color="#0099ff">封装，继承，多态</font>）；</li><li>平台无关性（Java虚拟机实现平台无关性）；</li><li>可靠性；</li><li>安全性；</li><li>支持多线程；</li><li>支持网络编程并且很方便；</li><li>编译和解释并存；</li></ul><hr><h2 id="Java-和-C-的区别"><a href="#Java-和-C-的区别" class="headerlink" title="Java 和 C++ 的区别"></a><strong>Java 和 C++ 的区别</strong></h2><ul><li>都是面向对象语言，都支持封装、继承和多态</li><li>Java不提供指针来直接访问内存，程序内存更加安全</li><li>Java的类是单继承的，C++支持多重继承；虽然Java的类不可以多继承，但是接口可以多继承</li><li>Java有自动内存管理机制，不需要程序员手动释放无用内存</li><li><strong>在C语言中，字符串或字符数组最后都会有一个额外的字符‘\0’来表示结束。但是，Java语言中没有结束符这个概念</strong></li></ul><hr><h2 id="ArrayList，LinkedList-和-Vector的区别"><a href="#ArrayList，LinkedList-和-Vector的区别" class="headerlink" title="ArrayList，LinkedList 和 Vector的区别"></a><strong>ArrayList，LinkedList 和 Vector的区别</strong></h2><ol><li><strong>ArrayList是最常用的List实现类，内部通过数组实现的，</strong>它允许对元素进行随机访问。数组的缺点是每个元素之间不能有间隔，当数组大小不满足时需要增加存储能力。当从ArrayList的中间位置插入或者删除元素时，需要对数组进行复制、移动、代价比较高。因此，它适合随机查找和遍历，不适合插入和删除。</li><li><strong>Vector与ArrayList一样，也是通过数组实现的，</strong>不同的是它支持线程的同步，即某一时刻只有一个线程能够写Vector，但实现同步需要很高的花费，因此，访问它比访问ArrayList慢。</li><li><strong>LinkedList是采用链表结构存储数据的，</strong>很适合数据的动态插入和删除，但随机访问和遍历速度比较慢。另外，他还提供了List接口中没有定义的方法，专门用于操作表头和表尾元素，可以当作堆栈、队列和双向队列使用</li></ol><hr><h2 id="HashMap、Hashtable、LinkedHashMap、ConcurrentHashMap-和-TreeMap之间的区别"><a href="#HashMap、Hashtable、LinkedHashMap、ConcurrentHashMap-和-TreeMap之间的区别" class="headerlink" title="HashMap、Hashtable、LinkedHashMap、ConcurrentHashMap 和 TreeMap之间的区别"></a><strong>HashMap、Hashtable、LinkedHashMap、ConcurrentHashMap 和 TreeMap之间的区别</strong></h2><ol><li><strong>HashMap</strong>是一个最常用的Map，它根据键的hashCode值存储数据，根据键可以直接获取它的值，具有很快的访问速度。HashMap最多只允许一条记录的键为null，不允许多条记录的值为null。HashMap不支持线程的同步，即任一时刻可以有多个线程同时写HashMap，可能会导致数据的不一致。如果需要同步，可以用Collections.synchronizedMap(HashMap map)方法使HashMap具有同步的能力。</li></ol><table><thead><tr><th style="text-align:center">No</th><th style="text-align:center">HashMap</th><th style="text-align:center">HashTable</th></tr></thead><tbody><tr><td style="text-align:center">1</td><td style="text-align:center">继承的是AbstractMap类</td><td style="text-align:center">继承的的是Dicionary类</td></tr><tr><td style="text-align:center">2</td><td style="text-align:center">非线程安全</td><td style="text-align:center">线程安全</td></tr><tr><td style="text-align:center">3</td><td style="text-align:center">允许存在null的key</td><td style="text-align:center">不允许存在空key</td></tr></tbody></table><ol><li><strong>LinkedHashMap</strong>保存了记录的插入顺序，在用Iteraor遍历LinkedHashMap时，先得到的记录肯定是先插入的。在遍历的时候会比HashMap慢。有HashMap的全部特性。</li><li><strong>TreeMap</strong>能够把它保存的记录根据键排序，默认是按升序排序，也可以指定排序的比较器。当用Iteraor遍历TreeMap时，得到的记录是排过序的。TreeMap的键和值都不能为空。</li><li><strong>ConcurrentHashMap</strong>是无锁多线程编程所提供的一个集合组合，是基于cpu层面的CAS原子操作，用到这个操作，只需要在取队列元素和添加队列元素的时候利用CAS原子操作，就可以保证多个线程对队列元素的有序存取</li></ol><hr><h2 id="Object类有哪些方法？各有什么作用？"><a href="#Object类有哪些方法？各有什么作用？" class="headerlink" title="Object类有哪些方法？各有什么作用？"></a><strong>Object类有哪些方法？各有什么作用？</strong></h2><ol><li><strong>clone方法</strong></li></ol><p>保护方法，实现对象的浅复制，只有实现了Cloneable接口才可以调用该方法，否则抛出CloneNotSupportedException异常。</p><p>主要是JAVA里除了8种基本类型传参数是值传递，其他的类对象传参数都是引用传递，我们有时候不希望在方法里讲参数改变，这是就需要在类中复写clone方法。</p><ol start="2"><li><strong>getClass方法</strong></li></ol><p>final方法，获得运行时类型。</p><ol start="3"><li><strong>toString方法</strong></li></ol><p>该方法用得比较多，一般子类都有覆盖。</p><ol start="4"><li><strong>finalize方法</strong></li></ol><p>该方法用于释放资源。因为无法确定该方法什么时候被调用，很少使用。</p><ol start="5"><li><strong>equals方法</strong></li></ol><p>该方法是非常重要的一个方法。一般equals和==是不一样的，但是在Object中两者是一样的。子类一般都要重写这个方法。</p><ol start="6"><li><strong>hashCode方法</strong></li></ol><p>该方法用于哈希查找，可以减少在查找中使用equals的次数，重写了equals方法一般都要重写hashCode方法。这个方法在一些具有哈希功能的Collection中用到。</p><p>一般必须满足obj1.equals(obj2)==true。可以推出obj1.hash- Code()==obj2.hashCode()，但是hashCode相等不一定就满足equals。不过为了提高效率，应该尽量使上面两个条件接近等价。</p><p>如果不重写hashcode(),在HashSet中添加两个equals的对象，会将两个对象都加入进去。</p><ol start="7"><li><strong>wait方法</strong></li></ol><p>wait方法就是使当前线程等待该对象的锁，当前线程必须是该对象的拥有者，也就是具有该对象的锁。wait()方法一直等待，直到获得锁或者被中断。wait(long timeout)设定一个超时间隔，如果在规定时间内没有获得锁就返回。</p><p>调用该方法后当前线程进入睡眠状态，直到以下事件发生。</p><p>（1）其他线程调用了该对象的notify方法。</p><p>（2）其他线程调用了该对象的notifyAll方法。</p><p>（3）其他线程调用了interrupt中断该线程。</p><p>（4）时间间隔到了。</p><p>此时该线程就可以被调度了，如果是被中断的话就抛出一个InterruptedException异常。</p><ol start="8"><li><strong>notify方法</strong></li></ol><p>该方法唤醒在该对象上等待的某个线程。</p><ol start="9"><li><strong>notifyAll方法</strong></li></ol><p>该方法唤醒在该对象上等待的所有线程。</p><hr><h2 id="Redis的数据类型"><a href="#Redis的数据类型" class="headerlink" title="Redis的数据类型"></a><strong>Redis的数据类型</strong></h2><p>Redis支持五种数据类型：string（字符串），hash（哈希），list（列表），set（集合）及zset(sorted set：有序集合)。</p><p><a href="https://www.cnblogs.com/ysocean/p/9080940.html" target="_blank" rel="noopener">Redis详解（三）—— redis的六大数据类型详细用法</a></p><p><img src="/2021/08/16/java/Redis.png" alt loading="lazy"></p><ol><li><strong>String（字符串）</strong>        </li></ol><p>string 是 redis 最基本的类型，你可以理解成与 Memcached 一模一样的类型，一个 key 对应一个 value。</p><p>string 类型是二进制安全的。意思是 redis 的 string 可以包含任何数据。比如jpg图片或者序列化的对象。</p><p>string 类型是 Redis 最基本的数据类型，string 类型的值最大能存储 512MB。</p><ol start="2"><li><strong>Hash（哈希）</strong></li></ol><p>Redis hash 是一个键值(key=&gt;value)对集合。</p><p>Redis hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象。</p><ol start="3"><li><strong>List（列表）</strong></li></ol><p>Redis 列表是简单的字符串列表，按照插入顺序排序。你可以添加一个元素到列表的头部（左边）或者尾部（右边）。</p><ol start="4"><li><p><strong>Set（集合）</strong></p><p>Redis 的 Set 是 string 类型的无序集合。</p><p>集合是通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。</p></li></ol><ol start="5"><li><p><strong>zset(sorted set：有序集合)</strong></p><p>Redis zset 和 set 一样也是string类型元素的集合,且不允许重复的成员。</p><p>不同的是每个元素都会关联一个double类型的分数。redis正是通过分数来为集合中的成员进行从小到大的排序。</p><p>zset的成员是唯一的,但分数(score)却可以重复。</p></li></ol><hr><h2 id="Redis数据类型的底层数据结构"><a href="#Redis数据类型的底层数据结构" class="headerlink" title="Redis数据类型的底层数据结构"></a><strong>Redis数据类型的底层数据结构</strong></h2><p>简单动态字符串、链表、字典、跳跃表、整数集合、压缩列表<br><a href="https://www.cnblogs.com/ysocean/p/9080942.html" target="_blank" rel="noopener">Redis详解（四）—— redis的底层数据结构</a></p><hr><h2 id="Redis持久化机制"><a href="#Redis持久化机制" class="headerlink" title="Redis持久化机制"></a>Redis持久化机制</h2><p><a href="https://baijiahao.baidu.com/s?id=1654694618189745916&amp;wfr=spider&amp;for=pc" target="_blank" rel="noopener">详解Redis中两种持久化机制RDB和AOF（面试常问，工作常用）</a></p><hr><h2 id="详解第一范式、第二范式、第三范式、BCNF范式"><a href="#详解第一范式、第二范式、第三范式、BCNF范式" class="headerlink" title="详解第一范式、第二范式、第三范式、BCNF范式"></a>详解第一范式、第二范式、第三范式、BCNF范式</h2><ul><li>[x] 1NF： 字段是最小的的单元不可再分</li><li>[x] 2NF：满足1NF,表中的字段必须完全依赖于全部主键而非部分主键 (解决部分函数依赖问题)</li><li>[x] 3NF：满足2NF,非主键外的所有字段必须互不依赖（解决传递函数依赖问题）</li><li>[ ] 4NF：满足3NF,消除表中的多值依赖</li></ul><p><a href="https://blog.csdn.net/Wenco1/article/details/88077279?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.baidujsUnder6&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.baidujsUnder6" target="_blank" rel="noopener">详解第一范式、第二范式、第三范式、BCNF范式</a></p><hr><h2 id="B树与B-树简明扼要的区别"><a href="#B树与B-树简明扼要的区别" class="headerlink" title="B树与B+树简明扼要的区别"></a>B树与B+树简明扼要的区别</h2><p><strong>B树</strong> : 每个节点都存储key和data，所有节点组成这棵树，并且叶子节点指针为null。</p><p><img src="/2021/08/16/java/BTree.png" alt loading="lazy"></p><p><strong>B+树</strong> : 只有叶子节点存储data，叶子节点包含了这棵树的所有键值，叶子节点不存储指针。</p><p><img src="/2021/08/16/java/B+Tree.png" alt loading="lazy"></p><p>后来，在B+树上增加了<strong>顺序访问指针</strong>，也就是每个叶子节点增加一个指向相邻叶子节点的指针，这样一棵树成了数据库系统实现索引的首选数据结构。 </p><p>  原因有很多，最主要的是这棵树矮胖，呵呵。一般来说，索引很大，往往以索引文件的形式存储的磁盘上，索引查找时产生磁盘I/O消耗，相对于内存存取，I/O存取的消耗要高几个数量级，所以评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘I/O操作次数的时间复杂度。树高度越小，I/O次数越少。 </p><p>  <strong>那为什么是B+树而不是B树呢，因为它内节点不存储data，这样一个节点就可以存储更多的key。</strong></p><hr><h2 id="在MySQL中，最常用的两个存储引擎是MyISAM和InnoDB"><a href="#在MySQL中，最常用的两个存储引擎是MyISAM和InnoDB" class="headerlink" title="在MySQL中，最常用的两个存储引擎是MyISAM和InnoDB"></a>在MySQL中，最常用的两个存储引擎是MyISAM和InnoDB</h2><p><strong>MyISAM</strong> : data存的是数据地址。索引是索引，数据是数据。索引放在XX.MYI文件中，数据放在XX.MYD文件中，所以也叫非聚集索引。</p><p><img src="/2021/08/16/java/MyISAM.png" alt loading="lazy"></p><p><strong>InnoDB</strong> : data存的是数据本身。索引也是数据。数据和索引存在一个XX.IDB文件中，所以也叫聚集索引。</p><p><img src="/2021/08/16/java/InnoDB.png" alt loading="lazy"></p><p>两种存储引擎的区别：</p><p>1、MyISAM是非事务安全的，而InnoDB是事务安全的</p><p>2、MyISAM锁的粒度是表级的，而InnoDB支持行级锁</p><p>3、MyISAM支持全文类型索引，而InnoDB不支持全文索引</p><p>4、MyISAM相对简单，效率上要优于InnoDB，小型应用可以考虑使用MyISAM</p><p>5、MyISAM表保存成文件形式，跨平台使用更加方便</p><p>6、MyISAM管理非事务表，提供高速存储和检索以及全文搜索能力，如果在应用中执行大量select操作可选择</p><p>7、InnoDB用于事务处理，具有ACID事务支持等特性，如果在应用中执行大量insert和update操作，可选择。</p><hr><h2 id="MySQL的MVCC及实现原理"><a href="#MySQL的MVCC及实现原理" class="headerlink" title="MySQL的MVCC及实现原理"></a>MySQL的MVCC及实现原理</h2><p><a href="https://blog.csdn.net/SnailMann/article/details/94724197?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.essearch_pc_relevant&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-2.essearch_pc_relevant" target="_blank" rel="noopener">【MySQL笔记】正确的理解MySQL的MVCC及实现原理</a></p><hr><h2 id="JVM的CMS的步骤？为什么要执行第二部的并发标记？"><a href="#JVM的CMS的步骤？为什么要执行第二部的并发标记？" class="headerlink" title="JVM的CMS的步骤？为什么要执行第二部的并发标记？"></a>JVM的CMS的步骤？为什么要执行第二部的并发标记？</h2><hr><h2 id="GCRoot的对象有哪些？"><a href="#GCRoot的对象有哪些？" class="headerlink" title="GCRoot的对象有哪些？"></a>GCRoot的对象有哪些？</h2><hr><h2 id="volatile的实现原理？"><a href="#volatile的实现原理？" class="headerlink" title="volatile的实现原理？"></a><strong>volatile的实现原理？</strong></h2><p>volatile通常被比喻成”轻量级的synchronized”，也是Java并发编程中比较重要的一个关键字。和synchronized不同，volatile是一个变量修饰符，只能用来修饰变量。无法修饰方法及代码块等。</p><p>volatile的用法比较简单，只需要在声明一个可能被多线程同时访问的变量时，使用volatile修饰就可以了。</p><p><strong>volatile的原理：</strong>为了提高处理器的执行速度，在处理器和内存之间增加了多级缓存来提升。但是由于引入了多级缓存，就存在缓存数据不一致问题。</p><p>但是，对于volatile变量，当对volatile变量进行写操作的时候，JVM会向处理器发送一条lock前缀的指令，将这个缓存中的变量回写到系统主存中。</p><p>但是就算写回到内存，如果其他处理器缓存的值还是旧的，再执行计算操作就会有问题，所以在多处理器下，为了保证各个处理器的缓存是一致的，就会实现缓存一致性协议</p><p>缓存一致性协议：每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了，当处理器发现自己缓存行对应的内存地址被修改，就会将当前处理器的缓存行设置成无效状态，当处理器要对这个数据进行修改操作的时候，会强制重新从系统内存里把数据读到处理器缓存里。</p><p>所以，如果一个变量被volatile所修饰的话，在每次数据变化之后，其值都会被强制刷入主存。而其他处理器的缓存由于遵守了缓存一致性协议，也会把这个变量的值从主存加载到自己的缓存中。这就保证了一个volatile在并发编程中，其值在多个缓存中是可见的。</p><hr><h2 id="常见排序算法及其对应的时间复杂度和空间复杂度"><a href="#常见排序算法及其对应的时间复杂度和空间复杂度" class="headerlink" title="常见排序算法及其对应的时间复杂度和空间复杂度"></a>常见排序算法及其对应的时间复杂度和空间复杂度</h2><p><a href="https://www.cnblogs.com/zwtgyh/p/10631760.html" target="_blank" rel="noopener">常见排序算法及其对应的时间复杂度和空间复杂度</a></p><hr><h2 id="GC垃圾回收算法"><a href="#GC垃圾回收算法" class="headerlink" title="GC垃圾回收算法"></a><strong>GC垃圾回收算法</strong></h2><p><img src="/2021/08/16/java/GC.png" alt loading="lazy"></p><hr><h2 id="HashMap为什么线程不安全？ConcurrentHashMap的原理？"><a href="#HashMap为什么线程不安全？ConcurrentHashMap的原理？" class="headerlink" title="HashMap为什么线程不安全？ConcurrentHashMap的原理？"></a>HashMap为什么线程不安全？ConcurrentHashMap的原理？</h2><p>首先我们之前说到过 HashMap 在第一次 put 的时候，会进行哈希数组的初始化，我们想想这次会有线程安全问题么？肯定有呀，要是两个线程同时对 HashMap 进行初始化，那么我们不就有了两个 哈希数组了么？</p><p><a href="https://blog.csdn.net/newbie0107/article/details/101164483" target="_blank" rel="noopener">剖析HashMap的线程不安全到ConCurrentHashMap如何保证其安全性</a></p><hr><h2 id="synchronized的原理？"><a href="#synchronized的原理？" class="headerlink" title="synchronized的原理？"></a>synchronized的原理？</h2><hr><h2 id="分布式锁有哪些实现方式？"><a href="#分布式锁有哪些实现方式？" class="headerlink" title="分布式锁有哪些实现方式？"></a>分布式锁有哪些实现方式？</h2><hr><h2 id="redis怎么实现分布式锁？"><a href="#redis怎么实现分布式锁？" class="headerlink" title="redis怎么实现分布式锁？"></a><a href="https://www.nowcoder.com/jump/super-jump/word?word=redis" target="_blank" rel="noopener">redis</a>怎么实现分布式锁？</h2><hr><h2 id="给了一个redis分布式锁的场景，问是否发生死锁？"><a href="#给了一个redis分布式锁的场景，问是否发生死锁？" class="headerlink" title="给了一个redis分布式锁的场景，问是否发生死锁？"></a>给了一个<a href="https://www.nowcoder.com/jump/super-jump/word?word=redis" target="_blank" rel="noopener">redis</a>分布式锁的场景，问是否发生死锁？</h2><hr><h2 id="redis分布式锁除了设置过期时间外，还有什么办法可以解决死锁？"><a href="#redis分布式锁除了设置过期时间外，还有什么办法可以解决死锁？" class="headerlink" title="redis分布式锁除了设置过期时间外，还有什么办法可以解决死锁？"></a><a href="https://www.nowcoder.com/jump/super-jump/word?word=redis" target="_blank" rel="noopener">redis</a>分布式锁除了设置过期时间外，还有什么办法可以解决死锁？</h2><hr><h2 id="Zookepeer又怎么实现分布式锁"><a href="#Zookepeer又怎么实现分布式锁" class="headerlink" title="Zookepeer又怎么实现分布式锁?"></a>Zookepeer又怎么实现分布式锁?</h2><hr><h2 id="分布式事务有哪些实现方式？"><a href="#分布式事务有哪些实现方式？" class="headerlink" title="分布式事务有哪些实现方式？"></a>分布式事务有哪些实现方式？</h2><hr>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;面向过程和面向对象的区别&quot;&gt;&lt;a href=&quot;#面向过程和面向对象的区别&quot; class=&quot;headerlink&quot; title=&quot;面向过程和面向对象的区别&quot;&gt;&lt;/a&gt;&lt;strong&gt;面向过程和面向对象的区别&lt;/strong&gt;&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;面向过程：面向过程性能比面向对象高&lt;/strong&gt;。因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。但是，&lt;strong&gt;面向过程没有面向对象易维护、易复用、易扩展&lt;/strong&gt;。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;面向对象：面向对象易维护、易复用、易扩展&lt;/strong&gt;。因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易维护。但是，&lt;strong&gt;面向对象性能比面向过程低&lt;/strong&gt;。&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Java面试" scheme="http://xusanjin.com/categories/Java%E9%9D%A2%E8%AF%95/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="面试" scheme="http://xusanjin.com/tags/%E9%9D%A2%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>小美的水洼地冒险</title>
    <link href="http://xusanjin.com/2021/08/15/arithmetic94/"/>
    <id>http://xusanjin.com/2021/08/15/arithmetic94/</id>
    <published>2021-08-15T11:10:00.000Z</published>
    <updated>2021-08-18T03:51:47.717Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>小美现在想要经过一个总距离长为 n 的水洼地。其中一些地块是水坑，另一些是地面。开始的时候小美位于这段水洼地的首个地块的位置。很显然小美不想自己的鞋湿掉。于是小美想出一个办法：小美每次可以跳到非水坑的地方。不过小美的力气有限，每一步都至多跳距离 p 。换句话说，小美当前位置在第i个方块上，那么小美的下一步可以位于 [i+1, i+p]之间的非水坑的地块上。但小美每跳一步都会消耗力气，跳不同的距离对小美的力气消耗是不同的。你的任务是帮助小美计算最小的力气消耗，即保证小美跳到第 n 个地块的前提下（注意：刚好是第 n 个地块，本题中不存在 n+1 之后的地块），求出最少花费多少力气。</p><a id="more"></a><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：第一行两个正整数n和p，空格隔开，n表示地块的数量，p表示小美单次的最远跳跃的距离。</p><p>接下来一行一个长度为n的字符串，只包含小写字母o和小写字母x，其中小写字母o表示地面，小写字母x表示水坑。保证字符串中的首个字符和末位字符一定是地面（即小写字母o），保证从起点到终点至少存在一种合法路径。</p><p>接下来一行p个正整数，第i个数字表示小美跳跃距离i所需要花费的体力值。（请注意：不保证小美跳的近就一定花费更少的力气）</p><p>10 5</p><p>oxxoooxxxo</p><p>1 6 9 15 18</p><p>输出：一行一个正整数表示小美最少花费的体力值</p><p>26</p><p>解释：</p><p>地块1 → 地块4 → 地块5 → 地块6 → 地块10</p><p>共计花费力气 9 + 1 + 1 + 15 = 26</p></blockquote><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li>对于40%的数据保证 n ≦ 100, 5 ≦ p ≦ 10</li><li>对于100%的数据保证 n ≦ 10000, 5 ≦ p ≦ 10</li><li>小美每步跳跃的力气保证是个[1,100]之间的正整数。但要消耗的力气越大。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Scanner scanner <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Scanner</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>in<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>scanner<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> n <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> p <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String map <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cost <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>p<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> p<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> scanner<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> dp <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">100088999</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            dp<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token string">'o'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;=</span> p<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">-</span> j<span class="token punctuation">)</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> map<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i <span class="token operator">-</span> j<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token string">'x'</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>i <span class="token operator">-</span> j<span class="token punctuation">]</span> <span class="token operator">+</span> cost<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> dp<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>i <span class="token operator">-</span> j<span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">break</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dp<span class="token punctuation">[</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;小美现在想要经过一个总距离长为 n 的水洼地。其中一些地块是水坑，另一些是地面。开始的时候小美位于这段水洼地的首个地块的位置。很显然小美不想自己的鞋湿掉。于是小美想出一个办法：小美每次可以跳到非水坑的地方。不过小美的力气有限，每一步都至多跳距离 p 。换句话说，小美当前位置在第i个方块上，那么小美的下一步可以位于 [i+1, i+p]之间的非水坑的地块上。但小美每跳一步都会消耗力气，跳不同的距离对小美的力气消耗是不同的。你的任务是帮助小美计算最小的力气消耗，即保证小美跳到第 n 个地块的前提下（注意：刚好是第 n 个地块，本题中不存在 n+1 之后的地块），求出最少花费多少力气。&lt;/p&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>加油站</title>
    <link href="http://xusanjin.com/2021/08/14/arithmetic93/"/>
    <id>http://xusanjin.com/2021/08/14/arithmetic93/</id>
    <published>2021-08-14T11:10:00.000Z</published>
    <updated>2021-08-18T03:51:47.675Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。</p><p>你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。</p><p>如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：</p><p>gas  = [1,2,3,4,5]<br>cost = [3,4,5,1,2]</p><p>输出：3</p><p>解释：</p><p>从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油<br>开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油<br>开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油<br>开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油<br>开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油<br>开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。<br>因此，3 可为起始索引。</p></blockquote><a id="more"></a><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li>如果题目有解，该答案即为唯一答案。</li><li>输入数组均为非空数组，且长度相同。</li><li>输入数组中的元素均为非负数。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src="/2021/08/14/arithmetic93/1.png" alt loading="lazy"></p><ol><li>首先判断总gas能不能大于等于总cost，如果总gas不够，一切都白搭对吧（总（gas- cost）不用单独去计算，和找最低点时一起计算即可，只遍历一次）；</li><li>再就是找总（gas-cost）的最低点，不管正负（当然如果最低点都是正的话那肯定能跑完了）；</li><li>找到最低点后，如果有解，那么解就是最低点的下一个点，因为总（gas-cost）是大于等于0的，所以前面损失的gas我从最低点下一个点开始都会拿回来！</li></ol><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">canCompleteCircuit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> gas<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> cost<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> len <span class="token operator">=</span> gas<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> spare <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> minSpare <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>    <span class="token keyword">int</span> minIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        spare <span class="token operator">+=</span> gas<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> cost<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>spare <span class="token operator">&lt;</span> minSpare<span class="token punctuation">)</span> <span class="token punctuation">{</span>            minSpare <span class="token operator">=</span> spare<span class="token punctuation">;</span>            minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> spare <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">(</span>minIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> len<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;在一条环路上有 N 个加油站，其中第 i 个加油站有汽油 gas[i] 升。&lt;/p&gt;
&lt;p&gt;你有一辆油箱容量无限的的汽车，从第 i 个加油站开往第 i+1 个加油站需要消耗汽油 cost[i] 升。你从其中的一个加油站出发，开始时油箱为空。&lt;/p&gt;
&lt;p&gt;如果你可以绕环路行驶一周，则返回出发时加油站的编号，否则返回 -1。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入：&lt;/p&gt;
&lt;p&gt;gas  = [1,2,3,4,5]&lt;br&gt;cost = [3,4,5,1,2]&lt;/p&gt;
&lt;p&gt;输出：3&lt;/p&gt;
&lt;p&gt;解释：&lt;/p&gt;
&lt;p&gt;从 3 号加油站(索引为 3 处)出发，可获得 4 升汽油。此时油箱有 = 0 + 4 = 4 升汽油&lt;br&gt;开往 4 号加油站，此时油箱有 4 - 1 + 5 = 8 升汽油&lt;br&gt;开往 0 号加油站，此时油箱有 8 - 2 + 1 = 7 升汽油&lt;br&gt;开往 1 号加油站，此时油箱有 7 - 3 + 2 = 6 升汽油&lt;br&gt;开往 2 号加油站，此时油箱有 6 - 4 + 3 = 5 升汽油&lt;br&gt;开往 3 号加油站，你需要消耗 5 升汽油，正好足够你返回到 3 号加油站。&lt;br&gt;因此，3 可为起始索引。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>形成两个异或相等数组的三元组数目</title>
    <link href="http://xusanjin.com/2021/08/14/arithmetic92/"/>
    <id>http://xusanjin.com/2021/08/14/arithmetic92/</id>
    <published>2021-08-14T10:52:00.000Z</published>
    <updated>2021-08-18T03:51:47.669Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数数组 arr 。</p><p>现需要从数组中取三个下标 i、j 和 k ，其中 (0 &lt;= i &lt; j &lt;= k &lt; arr.length) 。</p><p>a 和 b 定义如下：</p><p>a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1]<br>b = arr[j] ^ arr[j + 1] ^ … ^ arr[k]<br>注意：^ 表示 按位异或 操作。</p><p>请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：arr = [2,3,1,6,7]</p><p>输出：4</p><p>解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)</p></blockquote><a id="more"></a><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li><code>1 &lt;= arr.length &lt;= 300</code></li><li><code>1 &lt;= arr[i] &lt;= 10^8</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>S<sub>i</sub> ⊕ S<sub>j</sub> = (arr<sub>0</sub> ⊕ arr<sub>1</sub> ⊕⋯⊕ arr<sub>i−1</sub>) ⊕ (arr<sub>0</sub> ⊕ arr<sub>1</sub> ⊕⋯⊕ arr<sub>i−1</sub> ⊕ arr<sub>i</sub> ⊕⋯⊕ arr<sub>j−1</sub>）</p><p>由于异或运算满足结合律和交换律，且任意数异或自身等于 0，上式可化简为:</p><p>S<sub>i</sub> ⊕ S<sub>j</sub> = (arr<sub>i</sub>  ⊕⋯⊕ arr<sub>j</sub>) </p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">countTriplets</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> s <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            s<span class="token punctuation">[</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">^</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> ans <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> <span class="token operator">++</span>k<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> s<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    ans <span class="token operator">+=</span> k <span class="token operator">-</span> i<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//[i+1,k] 的范围内的任意 j 都是符合要求的，对应的三元组个数为 k-i</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数数组 arr 。&lt;/p&gt;
&lt;p&gt;现需要从数组中取三个下标 i、j 和 k ，其中 (0 &amp;lt;= i &amp;lt; j &amp;lt;= k &amp;lt; arr.length) 。&lt;/p&gt;
&lt;p&gt;a 和 b 定义如下：&lt;/p&gt;
&lt;p&gt;a = arr[i] ^ arr[i + 1] ^ … ^ arr[j - 1]&lt;br&gt;b = arr[j] ^ arr[j + 1] ^ … ^ arr[k]&lt;br&gt;注意：^ 表示 按位异或 操作。&lt;/p&gt;
&lt;p&gt;请返回能够令 a == b 成立的三元组 (i, j , k) 的数目。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入：arr = [2,3,1,6,7]&lt;/p&gt;
&lt;p&gt;输出：4&lt;/p&gt;
&lt;p&gt;解释：满足题意的三元组分别是 (0,1,2), (0,2,2), (2,3,4) 以及 (2,4,4)&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>数字流的秩</title>
    <link href="http://xusanjin.com/2021/08/12/arithmetic90/"/>
    <id>http://xusanjin.com/2021/08/12/arithmetic90/</id>
    <published>2021-08-12T11:57:00.000Z</published>
    <updated>2021-08-18T03:51:47.630Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：</p><p>实现 track(int x) 方法，每读入一个数字都会调用该方法；</p><p>实现 getRankOfNumber(int x) 方法，返回小于或等于 x 的值的个数。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：[“StreamRank”, “getRankOfNumber”, “track”, “getRankOfNumber”]<br>           [[], [1], [0], [0]]</p><p>输出：[null,0,null,1]</p></blockquote><a id="more"></a><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li><code>x &lt;= 50000</code></li><li><code>track</code> 和 <code>getRankOfNumber</code> 方法的调用次数均不超过 2000 次</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">StreamRank</span> <span class="token punctuation">{</span>    List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">StreamRank</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            list<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">track</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        list<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getRankOfNumber</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> res<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span>i<span class="token operator">&lt;</span>list<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span><span class="token punctuation">(</span>list<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">&lt;=</span> x<span class="token punctuation">)</span><span class="token punctuation">{</span>                        res<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span> res<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;假设你正在读取一串整数。每隔一段时间，你希望能找出数字 x 的秩(小于或等于 x 的值的个数)。请实现数据结构和算法来支持这些操作，也就是说：&lt;/p&gt;
&lt;p&gt;实现 track(int x) 方法，每读入一个数字都会调用该方法；&lt;/p&gt;
&lt;p&gt;实现 getRankOfNumber(int x) 方法，返回小于或等于 x 的值的个数。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入：[“StreamRank”, “getRankOfNumber”, “track”, “getRankOfNumber”]&lt;br&gt;           [[], [1], [0], [0]]&lt;/p&gt;
&lt;p&gt;输出：[null,0,null,1]&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>反转字符串中的单词 III</title>
    <link href="http://xusanjin.com/2021/08/12/arithmetic91/"/>
    <id>http://xusanjin.com/2021/08/12/arithmetic91/</id>
    <published>2021-08-12T10:32:00.000Z</published>
    <updated>2021-08-18T03:51:47.655Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：”Let’s take LeetCode contest”</p><p>输出：”s’teL ekat edoCteeL tsetnoc”</p></blockquote><a id="more"></a><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li>在字符串中，每个单词由单个空格分隔，并且字符串中不会有任何额外的空格。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把字符串转成字符数组，遍历字符数组；<br>我们只关心空格字符和最后一个字符，于是，遇到正常的字母字符一概不管；<br>当遇到空格字符，就需要对刚刚遍历过的单词进行反转操作，此单词的右索引是 i - 1，如何获取左索引？定义一个int变量start，用来记录单词的左索引；<br>利用字符数组前后交换字符位置的方法进行反转操作；反转结束后，把start索引置为 i + 1，指向下一个单词的开头；<br>遍历继续，直到遇到下一个空格字符或结尾；<br>到了字符数组结尾，那么最后一个单词的开头和结束索引分别是 start 和 n - 1，利用这两个索引进行单词翻转；<br>最后用String的构造方法，将char数组转成答案返回。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> String <span class="token function">reverseWords</span><span class="token punctuation">(</span>String s<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> start <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">' '</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">reverse</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> start<span class="token punctuation">,</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                start <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 更新start为下一个单词的左索引</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">==</span> array<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">reverse</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> start<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">reverse</span><span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>l <span class="token operator">&lt;</span> r<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>l<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>l<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>r<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>r<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            l <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>            r <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个字符串，你需要反转字符串中每个单词的字符顺序，同时仍保留空格和单词的初始顺序。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入：”Let’s take LeetCode contest”&lt;/p&gt;
&lt;p&gt;输出：”s’teL ekat edoCteeL tsetnoc”&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>跳跃游戏</title>
    <link href="http://xusanjin.com/2021/08/11/arithmetic89/"/>
    <id>http://xusanjin.com/2021/08/11/arithmetic89/</id>
    <published>2021-08-11T10:32:00.000Z</published>
    <updated>2021-08-18T03:51:47.617Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个非负整数数组 <code>nums</code> ，你最初位于数组的 <strong>第一个下标</strong> 。</p><p>数组中的每个元素代表你在该位置可以跳跃的最大长度。</p><p>判断你是否能够到达最后一个下标。</p><a id="more"></a><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：nums = [2,3,1,1,4]</p><p>输出：true</p><p>解释：可以先跳 1 步，从下标 0 到达下标 1, 然后再从下标 1 跳 3 步到达最后一个下标。</p></blockquote><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>0 &lt;= nums[i] &lt;= 105</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>我们可以用贪心的方法解决这个问题。</p><p>设想一下，对于数组中的任意一个位置 y，我们如何判断它是否可以到达？根据题目的描述，只要存在一个位置 x，它本身可以到达，并且它跳跃的最大长度为 x+nums[x]，这个值大于等于 yy，即 x+nums[x]≥y，那么位置 y 也可以到达。</p><p>换句话说，对于每一个可以到达的位置 xx，它使得 x+1,x+2,⋯,x+nums[x] 这些连续的位置都可以到达。</p><p>这样以来，我们依次遍历数组中的每一个位置，并实时维护 最远可以到达的位置。对于当前遍历到的位置 x，如果它在 最远可以到达的位置 的范围内，那么我们就可以从起点通过若干次跳跃到达该位置，因此我们可以用 x+nums[x] 更新 最远可以到达的位置。</p><p>在遍历的过程中，如果 最远可以到达的位置 大于等于数组中的最后一个位置，那就说明最后一个位置可达，我们就可以直接返回 True 作为答案。反之，如果在遍历结束后，最后一个位置仍然不可达，我们就返回 False 作为答案。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">canJump</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当前能够跳跃的最远下标</span>    <span class="token keyword">int</span> max <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> nums<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// i &lt;= max，表示能够达到下标 i 处</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> max<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 更新 max 值</span>            max <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>max<span class="token punctuation">,</span> nums<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果 max >= n-1，说明从当前位置能够跳跃到最后</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>max <span class="token operator">>=</span> n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个非负整数数组 &lt;code&gt;nums&lt;/code&gt; ，你最初位于数组的 &lt;strong&gt;第一个下标&lt;/strong&gt; 。&lt;/p&gt;
&lt;p&gt;数组中的每个元素代表你在该位置可以跳跃的最大长度。&lt;/p&gt;
&lt;p&gt;判断你是否能够到达最后一个下标。&lt;/p&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>按递增顺序显示卡牌</title>
    <link href="http://xusanjin.com/2021/08/11/arithmetic88/"/>
    <id>http://xusanjin.com/2021/08/11/arithmetic88/</id>
    <published>2021-08-11T09:48:00.000Z</published>
    <updated>2021-08-18T03:51:47.616Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。</p><p>最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。</p><p>现在，重复执行以下步骤，直到显示所有卡牌为止：</p><ol><li><p>从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。</p></li><li><p>如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。</p></li><li><p>如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。</p></li></ol><p>返回能以<strong>递增顺序</strong>显示卡牌的牌组顺序。</p><p>答案中的第一张牌被认为处于牌堆顶部。</p><a id="more"></a><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：[17,13,11,2,3,5,7]</p><p>输出：[2,13,3,11,5,17,7]</p><p>解释：</p><p>我们得到的牌组顺序为 [17,13,11,2,3,5,7]（这个顺序不重要），然后将其重新排序。<br>重新排序后，牌组以 [2,13,3,11,5,17,7] 开始，其中 2 位于牌组的顶部。<br>我们显示 2，然后将 13 移到底部。牌组现在是 [3,11,5,17,7,13]。<br>我们显示 3，并将 11 移到底部。牌组现在是 [5,17,7,13,11]。<br>我们显示 5，然后将 17 移到底部。牌组现在是 [7,13,11,17]。<br>我们显示 7，并将 13 移到底部。牌组现在是 [11,17,13]。<br>我们显示 11，然后将 17 移到底部。牌组现在是 [13,17]。<br>我们展示 13，然后将 17 移到底部。牌组现在是 [17]。<br>我们显示 17。<br>由于所有卡片都是按递增顺序排列显示的，所以答案是正确的。</p></blockquote><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li><code>1 &lt;= A.length &lt;= 1000</code></li><li><code>1 &lt;= A[i] &lt;= 10^6</code></li><li>对于所有的 <code>i != j</code>，<code>A[i] != A[j]</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>直接模拟从牌组中取牌的过程就可以了。举个例子，如果从牌组中以 [0, 2, 4, …] 的顺序取牌，我们只需要把最小的牌放在下标为 0 的地方，第二小的牌放在下标为 2 的地方，第三小的牌放在下标为 4 的地方，依次类推即可。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">deckRevealedIncreasing</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> deck<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> N <span class="token operator">=</span> deck<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        Deque<span class="token operator">&lt;</span>Integer<span class="token operator">></span> index <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> N<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span>            index<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ans <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>N<span class="token punctuation">]</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>deck<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> card<span class="token operator">:</span> deck<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ans<span class="token punctuation">[</span>index<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> card<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>index<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                index<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>index<span class="token punctuation">.</span><span class="token function">pollFirst</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> ans<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;牌组中的每张卡牌都对应有一个唯一的整数。你可以按你想要的顺序对这套卡片进行排序。&lt;/p&gt;
&lt;p&gt;最初，这些卡牌在牌组里是正面朝下的（即，未显示状态）。&lt;/p&gt;
&lt;p&gt;现在，重复执行以下步骤，直到显示所有卡牌为止：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;从牌组顶部抽一张牌，显示它，然后将其从牌组中移出。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果牌组中仍有牌，则将下一张处于牌组顶部的牌放在牌组的底部。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;如果仍有未显示的牌，那么返回步骤 1。否则，停止行动。&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;返回能以&lt;strong&gt;递增顺序&lt;/strong&gt;显示卡牌的牌组顺序。&lt;/p&gt;
&lt;p&gt;答案中的第一张牌被认为处于牌堆顶部。&lt;/p&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>扁平化嵌套列表迭代器</title>
    <link href="http://xusanjin.com/2021/08/10/arithmetic86/"/>
    <id>http://xusanjin.com/2021/08/10/arithmetic86/</id>
    <published>2021-08-10T09:37:00.000Z</published>
    <updated>2021-08-18T03:51:47.591Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。</p><p>实现扁平迭代器类 NestedIterator ：</p><ul><li>NestedIterator(List<NestedInteger> nestedList) 用嵌套列表 nestedList 初始化迭代器。</NestedInteger></li><li>int next() 返回嵌套列表的下一个整数。</li><li>boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。</li></ul><p>如果 <code>res</code> 与预期的扁平化列表匹配，那么你的代码将会被判为正确。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：nestedList = [[1,1],2,[1,1]]</p><p>输出：[1,1,2,1,1]</p><p>解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。</p></blockquote><a id="more"></a><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li><code>1 &lt;= nestedList.length &lt;= 500</code></li><li>嵌套列表中的整数值在范围 <code>[-106, 106]</code> 内</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>嵌套的整型列表是一个树形结构，树上的叶子节点对应一个整数，非叶节点对应一个列表。</p><p>在这棵树上深度优先搜索的顺序就是迭代器遍历的顺序。</p><p>我们可以先遍历整个嵌套列表，将所有整数存入一个数组，然后遍历该数组从而实现 next 和 hasNext 方法。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">NestedIterator</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> vals<span class="token punctuation">;</span>    <span class="token keyword">private</span> Iterator<span class="token operator">&lt;</span>Integer<span class="token operator">></span> cur<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">NestedIterator</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> nestedList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        vals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">dfs</span><span class="token punctuation">(</span>nestedList<span class="token punctuation">)</span><span class="token punctuation">;</span>        cur <span class="token operator">=</span> vals<span class="token punctuation">.</span><span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Integer <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cur<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> cur<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">dfs</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>NestedInteger<span class="token operator">></span> nestedList<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>NestedInteger nest <span class="token operator">:</span> nestedList<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>nest<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                vals<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>nest<span class="token punctuation">.</span><span class="token function">getInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">dfs</span><span class="token punctuation">(</span>nest<span class="token punctuation">.</span><span class="token function">getList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个嵌套的整数列表 nestedList 。每个元素要么是一个整数，要么是一个列表；该列表的元素也可能是整数或者是其他列表。请你实现一个迭代器将其扁平化，使之能够遍历这个列表中的所有整数。&lt;/p&gt;
&lt;p&gt;实现扁平迭代器类 NestedIterator ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NestedIterator(List&lt;NestedInteger&gt; nestedList) 用嵌套列表 nestedList 初始化迭代器。&lt;/NestedInteger&gt;&lt;/li&gt;
&lt;li&gt;int next() 返回嵌套列表的下一个整数。&lt;/li&gt;
&lt;li&gt;boolean hasNext() 如果仍然存在待迭代的整数，返回 true ；否则，返回 false 。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果 &lt;code&gt;res&lt;/code&gt; 与预期的扁平化列表匹配，那么你的代码将会被判为正确。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入：nestedList = [[1,1],2,[1,1]]&lt;/p&gt;
&lt;p&gt;输出：[1,1,2,1,1]&lt;/p&gt;
&lt;p&gt;解释：通过重复调用 next 直到 hasNext 返回 false，next 返回的元素的顺序应该是: [1,1,2,1,1]。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指 Offer II 010. 和为 k 的子数组</title>
    <link href="http://xusanjin.com/2021/08/10/arithmetic87/"/>
    <id>http://xusanjin.com/2021/08/10/arithmetic87/</id>
    <published>2021-08-10T07:28:00.000Z</published>
    <updated>2021-08-18T03:51:47.604Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组和一个整数 <code>k</code> <strong>，</strong>请找到该数组中和为 <code>k</code> 的连续子数组的个数。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：nums = [1,1,1], k = 2</p><p>输出：2</p><p>解释：此题 [1,1] 与 [1,1] 为两种不同的情况</p></blockquote><a id="more"></a><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li><code>1 &lt;= nums.length &lt;= 2 * 104</code></li><li><code>-1000 &lt;= nums[i] &lt;= 1000</code></li><li><code>-107 &lt;= k &lt;= 107</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>1.静态区间和—-&gt;前缀和</p><p>2.哈希字典加速查找</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">subarraySum</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> nums<span class="token punctuation">,</span> <span class="token keyword">int</span> k<span class="token punctuation">)</span>     <span class="token punctuation">{</span>        Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> Integer<span class="token operator">></span> presum_cnt <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        presum_cnt<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> res <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> pre <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> y <span class="token operator">:</span> nums<span class="token punctuation">)</span>        <span class="token punctuation">{</span>            pre <span class="token operator">+=</span> y<span class="token punctuation">;</span>            <span class="token keyword">int</span> x <span class="token operator">=</span> pre <span class="token operator">-</span> k<span class="token punctuation">;</span>            res <span class="token operator">+=</span> presum_cnt<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            presum_cnt<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> presum_cnt<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>pre<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组和一个整数 &lt;code&gt;k&lt;/code&gt; &lt;strong&gt;，&lt;/strong&gt;请找到该数组中和为 &lt;code&gt;k&lt;/code&gt; 的连续子数组的个数。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入：nums = [1,1,1], k = 2&lt;/p&gt;
&lt;p&gt;输出：2&lt;/p&gt;
&lt;p&gt;解释：此题 [1,1] 与 [1,1] 为两种不同的情况&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>和为零的N个唯一整数</title>
    <link href="http://xusanjin.com/2021/08/09/arithmetic85/"/>
    <id>http://xusanjin.com/2021/08/09/arithmetic85/</id>
    <published>2021-08-09T07:28:00.000Z</published>
    <updated>2021-08-18T03:51:47.584Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 <code>n</code>，请你返回 <strong>任意</strong> 一个由 <code>n</code> 个 <strong>各不相同</strong> 的整数组成的数组，并且这 <code>n</code> 个数相加和为 <code>0</code> 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：n = 5</p><p>输出：[-7,-1,1,3,4]</p><p>解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。</p></blockquote><a id="more"></a><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li><code>1 &lt;= n &lt;= 1000</code></li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>每两个两个加入数组就是了，+1，-1，+2，-2，奇偶可以不判断，奇数必定有一个 0，最后落单剩下的一个自然就是 0 了，数组初始化就是 0 了。</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sumZero</span><span class="token punctuation">(</span><span class="token keyword">int</span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> res <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>n<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            res<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>            res<span class="token punctuation">[</span>i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> res<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数 &lt;code&gt;n&lt;/code&gt;，请你返回 &lt;strong&gt;任意&lt;/strong&gt; 一个由 &lt;code&gt;n&lt;/code&gt; 个 &lt;strong&gt;各不相同&lt;/strong&gt; 的整数组成的数组，并且这 &lt;code&gt;n&lt;/code&gt; 个数相加和为 &lt;code&gt;0&lt;/code&gt; 。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入：n = 5&lt;/p&gt;
&lt;p&gt;输出：[-7,-1,1,3,4]&lt;/p&gt;
&lt;p&gt;解释：这些数组也是正确的 [-5,-1,1,2,3]，[-3,-1,2,-2,4]。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>长按键入</title>
    <link href="http://xusanjin.com/2021/08/09/arithmetic84/"/>
    <id>http://xusanjin.com/2021/08/09/arithmetic84/</id>
    <published>2021-08-09T07:14:00.000Z</published>
    <updated>2021-08-18T03:51:47.519Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。</p><p>你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：name = “alex”, typed = “aaleex”</p><p>输出：true</p><p>解释：’alex’ 中的 ‘a’ 和 ‘e’ 被长按。</p></blockquote><a id="more"></a><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li><code>name.length &lt;= 1000</code></li><li><code>typed.length &lt;= 1000</code></li><li><code>name</code> 和 <code>typed</code> 的字符都是小写字母。</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p><img src="/2021/08/09/arithmetic84/1.gif" alt loading="lazy"></p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isLongPressedName</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> String typed<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;</span> typed<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> name<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> name<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">==</span> typed<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                i<span class="token operator">++</span><span class="token punctuation">;</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> typed<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j<span class="token punctuation">)</span> <span class="token operator">==</span> typed<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                j<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> i <span class="token operator">==</span> name<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;你的朋友正在使用键盘输入他的名字 name。偶尔，在键入字符 c 时，按键可能会被长按，而字符可能被输入 1 次或多次。&lt;/p&gt;
&lt;p&gt;你将会检查键盘输入的字符 typed。如果它对应的可能是你的朋友的名字（其中一些字符可能被长按），那么就返回 True。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入：name = “alex”, typed = “aaleex”&lt;/p&gt;
&lt;p&gt;输出：true&lt;/p&gt;
&lt;p&gt;解释：’alex’ 中的 ‘a’ 和 ‘e’ 被长按。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>确定两个字符串是否接近</title>
    <link href="http://xusanjin.com/2021/08/08/arithmetic83/"/>
    <id>http://xusanjin.com/2021/08/08/arithmetic83/</id>
    <published>2021-08-08T11:46:00.000Z</published>
    <updated>2021-08-18T03:51:47.504Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 接近 ：</p><ul><li><p>操作 1：交换任意两个 现有 字符。</p><ul><li>例如，abcde -&gt; aecdb</li></ul></li><li><p>操作 2：将一个 现有 字符的每次出现转换为另一个 现有 字符，并对另一个字符执行相同的操作。</p><ul><li>例如，aacabb -&gt; bbcbaa（所有 a 转化为 b ，而所有的 b 转换为 a ）</li></ul><p>你可以根据需要对任意一个字符串多次使用这两种操作。</p></li></ul><p>给你两个字符串，word1 和 word2 。如果 word1 和 word2 接近 ，就返回 true ；否则，返回 false 。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><blockquote><p>输入：word1 = “cabbba”, word2 = “abbccc”</p><p>输出：true</p><p>解释：3 次操作从 word1 获得 word2 。<br>执行操作 1：”cabbba” -&gt; “caabbb”<br>执行操作 2：”caabbb” -&gt; “baaccc”<br>执行操作 2：”baaccc” -&gt; “abbccc”</p></blockquote><a id="more"></a><h2 id="限制"><a href="#限制" class="headerlink" title="限制"></a>限制</h2><ul><li><code>1 &lt;= word1.length, word2.length &lt;= 105</code></li><li><code>word1</code> 和 <code>word2</code> 仅包含小写英文字母</li></ul><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>把题目要求翻译成人话就是，<br>如果两个字符串：</p><ul><li>包含的字符种类完全一样；</li><li>把各个字符的重复次数放在一个数组里，数组在排序后完全一样；</li></ul><p>那么这两个字符串接近。</p><p>所以：</p><ul><li>如果两个字符串长度不一样，那么直接返回false；</li><li>遍历两个字符串，用两个长度 26 的数组存放次数；</li><li>同时遍历这两个数组，如果在某下标 i 处出现一个是 0 一个不是 0（即异或结果是 1）的情况，那么直接返回false；</li><li>排序后如果数组不相同，也返回false；</li><li>否则返回true。</li></ul><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">Solution</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">closeStrings</span><span class="token punctuation">(</span>String word1<span class="token punctuation">,</span> String word2<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> m <span class="token operator">=</span> word1<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> word2<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span><span class="token punctuation">(</span>m<span class="token operator">!=</span>n<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> l1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> l2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token number">26</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> m<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token operator">++</span>l1<span class="token punctuation">[</span>word1<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token operator">++</span>l2<span class="token punctuation">[</span>word2<span class="token punctuation">.</span><span class="token function">charAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token punctuation">(</span>l1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">^</span> <span class="token punctuation">(</span>l2<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>l1<span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>l2<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">26</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>l1<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">!=</span> l2<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;如果可以使用以下操作从一个字符串得到另一个字符串，则认为两个字符串 接近 ：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;p&gt;操作 1：交换任意两个 现有 字符。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，abcde -&amp;gt; aecdb&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;操作 2：将一个 现有 字符的每次出现转换为另一个 现有 字符，并对另一个字符执行相同的操作。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;例如，aacabb -&amp;gt; bbcbaa（所有 a 转化为 b ，而所有的 b 转换为 a ）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;你可以根据需要对任意一个字符串多次使用这两种操作。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;给你两个字符串，word1 和 word2 。如果 word1 和 word2 接近 ，就返回 true ；否则，返回 false 。&lt;/p&gt;
&lt;h2 id=&quot;示例&quot;&gt;&lt;a href=&quot;#示例&quot; class=&quot;headerlink&quot; title=&quot;示例&quot;&gt;&lt;/a&gt;示例&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;输入：word1 = “cabbba”, word2 = “abbccc”&lt;/p&gt;
&lt;p&gt;输出：true&lt;/p&gt;
&lt;p&gt;解释：3 次操作从 word1 获得 word2 。&lt;br&gt;执行操作 1：”cabbba” -&amp;gt; “caabbb”&lt;br&gt;执行操作 2：”caabbb” -&amp;gt; “baaccc”&lt;br&gt;执行操作 2：”baaccc” -&amp;gt; “abbccc”&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="算法题" scheme="http://xusanjin.com/categories/%E7%AE%97%E6%B3%95%E9%A2%98/"/>
    
    
      <category term="Java" scheme="http://xusanjin.com/tags/Java/"/>
    
      <category term="算法" scheme="http://xusanjin.com/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
</feed>
